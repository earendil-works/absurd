#!/usr/bin/env python3
import json
import os
import subprocess
import sys
import shutil
import textwrap
from urllib.request import urlopen
from urllib.error import URLError
from optparse import OptionParser, IndentedHelpFormatter


SQL_URL = "https://raw.githubusercontent.com/earendil-works/absurd/refs/heads/main/sql/absurd.sql"


def get_term_width():
    """Get terminal width for formatting."""
    try:
        return shutil.get_terminal_size().columns
    except Exception:
        return 80


class CleanHelpFormatter(IndentedHelpFormatter):
    """Custom formatter with better spacing and formatting."""

    def __init__(self):
        IndentedHelpFormatter.__init__(
            self,
            indent_increment=2,
            max_help_position=30,
            width=get_term_width(),
            short_first=1,
        )

    def format_option(self, option):
        result = []
        opts = self.option_strings[option]
        opt_width = self.help_position - self.current_indent - 2

        if len(opts) > opt_width:
            opts = "%*s%s\n" % (self.current_indent, "", opts)
            indent_first = self.help_position
        else:
            opts = "%*s%-*s  " % (self.current_indent, "", opt_width, opts)
            indent_first = 0

        result.append(opts)

        if option.help:
            help_text = self.expand_default(option)
            help_lines = []

            help_lines = textwrap.wrap(help_text, self.width - self.help_position)

            result.append("%*s%s\n" % (indent_first, "", help_lines[0]))
            for line in help_lines[1:]:
                result.append("%*s%s\n" % (self.help_position, "", line))
        elif opts[-1] != "\n":
            result.append("\n")

        return "".join(result)


def build_database_config(host=None, port=None, user=None, database=None):
    """Build a dict with database configuration."""
    return {
        "host": host or os.getenv("PGHOST", "localhost"),
        "port": port or os.getenv("PGPORT", "5432"),
        "user": user or os.getenv("PGUSER", os.getenv("USER", "")),
        "database": database or os.getenv("PGDATABASE", os.getenv("USER", "")),
    }


def config_from_options(options):
    """Shortcut to construct a database config from parsed options."""
    return build_database_config(
        options.host,
        options.port,
        options.user,
        options.database,
    )


def build_psql_command(config, extra_args=None):
    """Construct the base psql command with optional additional arguments."""
    cmd = [
        "psql",
        "-X",
        "-h",
        config["host"],
        "-p",
        config["port"],
        "-U",
        config["user"],
        "-d",
        config["database"],
    ]

    if extra_args:
        cmd.extend(extra_args)

    return cmd


def get_common_db_details(config):
    """Return standard database connection details for verbose output."""
    return [
        ("Host", config["host"]),
        ("Port", config["port"]),
        ("User", config["user"]),
        ("Database", config["database"]),
    ]


def print_verbose_configuration(enabled, details):
    """Print a formatted configuration block when verbose output is enabled."""
    if not enabled:
        return
    print("Configuration:")
    for label, value in details:
        print(f"  {label}: {value}")


def run_psql(
    config,
    query=None,
    *,
    tuples_only=False,
    no_align=False,
    extra_args=None,
    input_data=None,
    error_message=None,
):
    """
    Execute a PostgreSQL command. Returns stripped stdout for queries and the
    CompletedProcess for other invocations.
    """
    cmd_args = []

    if tuples_only:
        cmd_args.append("-t")
    if no_align:
        cmd_args.append("-A")
    if extra_args:
        cmd_args.extend(extra_args)
    if query is not None:
        cmd_args.extend(["-c", query])

    message = error_message
    if message is None:
        message = (
            "Error executing query"
            if query is not None
            else "Error executing psql command"
        )

    env = os.environ.copy()
    env["PGPASSWORD"] = os.getenv("PGPASSWORD", "")
    try:
        result = subprocess.run(
            build_psql_command(config, cmd_args),
            input=input_data,
            capture_output=True,
            text=True,
            check=True,
            env=env,
        )
    except subprocess.CalledProcessError as e:
        print(f"{message}: {e.stderr}", file=sys.stderr)
        sys.exit(1)

    if query is not None:
        return result.stdout.strip()
    return result


def queue_exists(config, queue_name):
    """Check if a queue exists."""
    result = run_psql(
        config,
        f"SELECT COUNT(*) FROM absurd.queues WHERE queue_name = '{queue_name}';",
        tuples_only=True,
        no_align=True,
    )
    return int(result) > 0


def build_json_params(param_list, base_params=None):
    """
    Build JSON parameters from -p flags and optional base --params.

    Supports:
      -p foo=bar           -> {"foo": "bar"}
      -p count:=42         -> {"count": 42}
      -p enabled:=true     -> {"enabled": true}
      -p tags:='["a","b"]' -> {"tags": ["a","b"]}
      -p user.name=Alice   -> {"user": {"name": "Alice"}}
      --params '{"x":1}'   -> merged with -p flags
    """
    result = {}

    if base_params:
        try:
            result = json.loads(base_params)
            if not isinstance(result, dict):
                raise ValueError("--params must be a JSON object")
        except json.JSONDecodeError as e:
            print(f"Error parsing --params: {e}", file=sys.stderr)
            sys.exit(1)

    for param in param_list:
        if ":=" in param:
            key, value_str = param.split(":=", 1)
            try:
                value = json.loads(value_str)
            except json.JSONDecodeError as e:
                print(f"Error parsing JSON value in '{param}': {e}", file=sys.stderr)
                sys.exit(1)
        elif "=" in param:
            key, value = param.split("=", 1)
        else:
            print(
                f"Invalid parameter format: '{param}' (expected key=value or key:=json)",
                file=sys.stderr,
            )
            sys.exit(1)

        set_nested_value(result, key, value)

    return json.dumps(result)


def set_nested_value(obj, path, value):
    """Set a value in a nested dictionary using dot notation."""
    keys = path.split(".")
    current = obj

    for key in keys[:-1]:
        if key not in current:
            current[key] = {}
        elif not isinstance(current[key], dict):
            print(
                f"Error: Cannot set nested value, '{key}' is not an object",
                file=sys.stderr,
            )
            sys.exit(1)
        current = current[key]

    current[keys[-1]] = value


def add_db_options(parser):
    """Add common database connection options to a parser."""
    parser.add_option("-h", "--host", dest="host", metavar="HOST", help="Database host")
    parser.add_option("-p", "--port", dest="port", metavar="PORT", help="Database port")
    parser.add_option("-U", "--user", dest="user", metavar="USER", help="Database user")
    parser.add_option(
        "-d", "--database", dest="database", metavar="DB", help="Database name"
    )
    parser.add_option(
        "-v",
        "--verbose",
        dest="verbose",
        action="store_true",
        default=False,
        help="Verbose output",
    )


def build_command_parser(usage):
    """Create an OptionParser with common Absurd defaults."""
    parser = OptionParser(
        usage=usage,
        add_help_option=False,
        formatter=CleanHelpFormatter(),
    )
    add_db_options(parser)
    parser.add_option("--help", action="store_true", help="Show this help message")
    return parser


def parse_args_with_help(parser, args, examples=None):
    """Parse args and handle --help in a consistent way."""
    options, remaining = parser.parse_args(args)
    if getattr(options, "help", False):
        parser.print_help()
        if examples:
            print("\nExamples:")
            for example in examples:
                print(f"  {example}")
        sys.exit(0)
    return options, remaining


def ensure_queue_exists(config, queue_name):
    """Exit with error if queue is missing."""
    if not queue_exists(config, queue_name):
        print(f"Queue '{queue_name}' does not exist", file=sys.stderr)
        sys.exit(1)


def cmd_cleanup(args):
    """Clean up old completed, failed, or cancelled tasks and events."""
    usage = "usage: %prog cleanup [options] QUEUE_NAME TTL_DAYS"
    parser = build_command_parser(usage)
    parser.add_option(
        "-l",
        "--limit",
        dest="limit",
        type="int",
        default=1000,
        help="Batch size for deletions (default: 1000)",
    )
    parser.add_option(
        "-n",
        "--dry-run",
        dest="dry_run",
        action="store_true",
        default=False,
        help="Show what would be deleted without actually deleting",
    )
    examples = [
        "absurdctl cleanup myqueue 30",
        "absurdctl cleanup --dry-run -v myqueue 30",
    ]

    options, args = parse_args_with_help(parser, args, examples)

    if len(args) != 2:
        print(
            "Error: Missing required arguments QUEUE_NAME and TTL_DAYS", file=sys.stderr
        )
        parser.print_help()
        sys.exit(1)

    queue_name = args[0]
    try:
        ttl_days = int(args[1])
    except ValueError:
        print(
            f"Error: TTL_DAYS must be a positive integer, got: {args[1]}",
            file=sys.stderr,
        )
        sys.exit(1)

    config = config_from_options(options)
    ensure_queue_exists(config, queue_name)

    ttl_seconds = ttl_days * 24 * 60 * 60

    print_verbose_configuration(
        options.verbose,
        [
            ("Queue", queue_name),
            ("TTL", f"{ttl_days} days ({ttl_seconds} seconds)"),
        ]
        + get_common_db_details(config)
        + [
            ("Limit", options.limit),
            ("Dry run", options.dry_run),
        ],
    )

    if options.dry_run:
        print("DRY RUN MODE - No data will be deleted")

        task_count = run_psql(
            config,
            f"""SELECT COUNT(*) FROM absurd.t_{queue_name} t
                LEFT JOIN absurd.r_{queue_name} r ON r.run_id = t.last_attempt_run
                WHERE t.state IN ('completed', 'failed', 'cancelled')
                AND ((t.state = 'completed' AND r.completed_at < NOW() - INTERVAL '{ttl_seconds} seconds')
                OR (t.state = 'failed' AND r.failed_at < NOW() - INTERVAL '{ttl_seconds} seconds')
                OR (t.state = 'cancelled' AND t.cancelled_at < NOW() - INTERVAL '{ttl_seconds} seconds'));""",
            tuples_only=True,
            no_align=True,
        )

        event_count = run_psql(
            config,
            f"SELECT COUNT(*) FROM absurd.e_{queue_name} WHERE emitted_at < NOW() - INTERVAL '{ttl_seconds} seconds';",
            tuples_only=True,
            no_align=True,
        )

        print(f"Would delete {task_count} tasks and {event_count} events")
        return

    print(f"Starting cleanup for queue '{queue_name}' (TTL: {ttl_days} days)")

    total_tasks_deleted = 0
    total_events_deleted = 0
    iteration = 0

    while True:
        iteration += 1

        if options.verbose:
            print(f"Iteration {iteration}...")

        tasks_deleted = int(
            run_psql(
                config,
                f"SELECT absurd.cleanup_tasks('{queue_name}', {ttl_seconds}, {options.limit});",
                tuples_only=True,
                no_align=True,
            )
        )
        total_tasks_deleted += tasks_deleted

        if options.verbose and tasks_deleted > 0:
            print(f"  Deleted {tasks_deleted} tasks")

        events_deleted = int(
            run_psql(
                config,
                f"SELECT absurd.cleanup_events('{queue_name}', {ttl_seconds}, {options.limit});",
                tuples_only=True,
                no_align=True,
            )
        )
        total_events_deleted += events_deleted

        if options.verbose and events_deleted > 0:
            print(f"  Deleted {events_deleted} events")

        if tasks_deleted == 0 and events_deleted == 0:
            break

        if tasks_deleted > 0 or events_deleted > 0:
            print(f"Deleted {tasks_deleted} tasks, {events_deleted} events")

    print(
        f"Cleanup complete: {total_tasks_deleted} tasks, {total_events_deleted} events deleted in {iteration} iterations"
    )


def cmd_create_queue(args):
    """Create a new Absurd queue."""
    usage = "usage: %prog create-queue [options] QUEUE_NAME"
    parser = build_command_parser(usage)

    options, args = parse_args_with_help(
        parser, args, ["absurdctl create-queue myqueue"]
    )

    if len(args) != 1:
        print("Error: Missing required argument QUEUE_NAME", file=sys.stderr)
        parser.print_help()
        sys.exit(1)

    queue_name = args[0]
    config = config_from_options(options)

    print_verbose_configuration(
        options.verbose,
        [("Queue", queue_name)] + get_common_db_details(config),
    )
    if options.verbose:
        print(f"Creating queue '{queue_name}'...")

    run_psql(config, f"SELECT absurd.create_queue('{queue_name}');")
    print(f"Queue '{queue_name}' created successfully")


def cmd_drop_queue(args):
    """Drop an existing Absurd queue."""
    usage = "usage: %prog drop-queue [options] QUEUE_NAME"
    parser = build_command_parser(usage)
    parser.add_option(
        "-y",
        "--yes",
        dest="yes",
        action="store_true",
        default=False,
        help="Skip confirmation prompt",
    )
    examples = [
        "absurdctl drop-queue myqueue",
        "absurdctl drop-queue --yes myqueue",
    ]

    options, args = parse_args_with_help(parser, args, examples)

    if len(args) != 1:
        print("Error: Missing required argument QUEUE_NAME", file=sys.stderr)
        parser.print_help()
        sys.exit(1)

    queue_name = args[0]
    config = config_from_options(options)

    ensure_queue_exists(config, queue_name)

    print_verbose_configuration(
        options.verbose,
        [("Queue", queue_name)] + get_common_db_details(config),
    )

    if not options.yes:
        print(
            f"WARNING: This will permanently delete queue '{queue_name}' and all its data."
        )
        response = input("Are you sure you want to continue? (yes/no): ")
        if response != "yes":
            print("Operation cancelled")
            return

    if options.verbose:
        print(f"Dropping queue '{queue_name}'...")

    run_psql(config, f"SELECT absurd.drop_queue('{queue_name}');")
    print(f"Queue '{queue_name}' dropped successfully")


def cmd_list_queues(args):
    """List all existing Absurd queues."""
    usage = "usage: %prog list-queues [options]"
    parser = build_command_parser(usage)

    options, args = parse_args_with_help(parser, args)

    config = config_from_options(options)

    result = run_psql(
        config, "SELECT * FROM absurd.list_queues();", tuples_only=True, no_align=True
    ).strip()
    if result:
        print(result)


def cmd_init(args):
    """Initialize the Absurd schema by applying absurd.sql."""
    usage = "usage: %prog init [options]"
    parser = build_command_parser(usage)

    options, args = parse_args_with_help(parser, args, ["absurdctl init"])

    config = config_from_options(options)

    print_verbose_configuration(options.verbose, get_common_db_details(config))

    script_dir = os.path.dirname(os.path.abspath(__file__))
    local_sql_path = os.path.join(script_dir, "sql", "absurd.sql")

    if os.path.exists(local_sql_path):
        if options.verbose:
            print(f"Using local SQL file: {local_sql_path}")

        result = run_psql(
            config,
            extra_args=["-f", local_sql_path],
            error_message="Error applying SQL file",
        )
    else:
        if options.verbose:
            print(f"Local SQL file not found, fetching from: {SQL_URL}")
        try:
            with urlopen(SQL_URL) as response:
                sql_content = response.read().decode("utf-8")
        except URLError as e:
            print(f"Error downloading SQL file from GitHub: {e}", file=sys.stderr)
            sys.exit(1)
        result = run_psql(
            config, input_data=sql_content, error_message="Error applying SQL file"
        )

    if options.verbose and result.stdout:
        print(result.stdout)
    print("Absurd schema initialized successfully")


def cmd_spawn_task(args):
    """Spawn a new task."""
    usage = "usage: %prog spawn-task [options] TASK_NAME"
    parser = build_command_parser(usage)

    parser.add_option(
        "-q",
        "--queue",
        dest="queue",
        metavar="NAME",
        help="Queue name (default: default)",
    )

    parser.add_option(
        "-P",
        "--param",
        dest="params",
        action="append",
        default=[],
        metavar="K=V",
        help="Task parameter. Use -P key=value for strings or -P key:=json for JSON values. "
        "Supports dotted paths for nested objects (e.g., -P user.name=Alice)",
    )
    parser.add_option(
        "--params",
        dest="base_params",
        metavar="JSON",
        help="Base JSON object for parameters (will be merged with -P flags)",
    )
    parser.add_option(
        "-H",
        "--header",
        dest="headers",
        action="append",
        default=[],
        metavar="K=V",
        help="Task header as key=value pair",
    )

    parser.add_option(
        "--max-attempts",
        dest="max_attempts",
        type="int",
        metavar="N",
        help="Maximum number of retry attempts",
    )
    parser.add_option(
        "--retry-kind",
        dest="retry_kind",
        metavar="KIND",
        help="Retry strategy: fixed, exponential, or none",
    )
    parser.add_option(
        "--retry-base",
        dest="retry_base",
        type="int",
        metavar="SECS",
        help="Base retry delay in seconds",
    )
    parser.add_option(
        "--retry-factor",
        dest="retry_factor",
        type="float",
        metavar="FACTOR",
        help="Exponential backoff multiplier (for exponential retry)",
    )
    parser.add_option(
        "--retry-max",
        dest="retry_max",
        type="int",
        metavar="SECS",
        help="Maximum retry delay cap in seconds",
    )

    parser.add_option(
        "--max-duration",
        dest="max_duration",
        type="int",
        metavar="SECS",
        help="Maximum task execution duration in seconds",
    )
    parser.add_option(
        "--max-delay",
        dest="max_delay",
        type="int",
        metavar="SECS",
        help="Maximum delay before task must start in seconds",
    )

    examples = [
        "absurdctl spawn-task my-task -P foo=bar -P count:=42",
        "absurdctl spawn-task my-task -P user.name=Alice -P user.age:=30",
        'absurdctl spawn-task my-task --params \'{"foo":"bar"}\' -P extra=value',
        "absurdctl spawn-task my-task -P email=test@example.com -q myqueue --max-attempts 5",
    ]

    options, args = parse_args_with_help(parser, args, examples)

    if len(args) != 1:
        print("Error: Missing required argument TASK_NAME", file=sys.stderr)
        parser.print_help()
        sys.exit(1)

    task_name = args[0]
    config = config_from_options(options)

    params_json = build_json_params(options.params, options.base_params)

    headers_json = "NULL"
    if options.headers:
        headers_dict = {}
        for header in options.headers:
            if "=" not in header:
                print(
                    f"Invalid header format: '{header}' (expected key=value)",
                    file=sys.stderr,
                )
                sys.exit(1)
            key, value = header.split("=", 1)
            headers_dict[key] = value
        headers_json = f"'{json.dumps(headers_dict)}'::jsonb"

    retry_json = "NULL"
    if (
        options.retry_kind
        or options.retry_base
        or options.retry_factor
        or options.retry_max
    ):
        retry = {"kind": options.retry_kind or "exponential"}
        if options.retry_base:
            retry["baseSeconds"] = options.retry_base
        if options.retry_factor:
            retry["factor"] = options.retry_factor
        if options.retry_max:
            retry["maxSeconds"] = options.retry_max
        retry_json = f"'{json.dumps(retry)}'::jsonb"

    cancellation_json = "NULL"
    if options.max_duration or options.max_delay:
        cancellation = {}
        if options.max_duration:
            cancellation["maxDuration"] = options.max_duration
        if options.max_delay:
            cancellation["maxDelay"] = options.max_delay
        cancellation_json = f"'{json.dumps(cancellation)}'::jsonb"

    queue = options.queue or "default"

    ensure_queue_exists(config, queue)

    details = [
        ("Task", task_name),
        ("Queue", queue),
        ("Params", params_json),
    ]
    if headers_json != "NULL":
        details.append(("Headers", headers_json))
    if options.max_attempts:
        details.append(("Max attempts", options.max_attempts))
    if retry_json != "NULL":
        details.append(("Retry strategy", retry_json))
    if cancellation_json != "NULL":
        details.append(("Cancellation", cancellation_json))
    details.extend(get_common_db_details(config))
    print_verbose_configuration(options.verbose, details)

    query = f"""
        SELECT task_id, run_id, attempt
        FROM absurd.spawn_task(
            '{queue}',
            '{task_name}',
            '{params_json}'::jsonb,
            {headers_json},
            {options.max_attempts or "NULL"},
            {retry_json},
            {cancellation_json}
        );
    """

    result = run_psql(config, query, tuples_only=True, no_align=True)

    if result:
        task_id, run_id, attempt = result.split("|")
        print(f"Task spawned successfully:")
        print(f"  Task ID: {task_id}")
        print(f"  Run ID: {run_id}")
        print(f"  Attempt: {attempt}")
    else:
        print("Task spawned, but no result returned", file=sys.stderr)


def show_help():
    print(
        """Usage: absurdctl COMMAND [OPTIONS]

A command-line utility for managing Absurd queues.

Commands:
  init            Initialize the Absurd schema by applying absurd.sql
  cleanup         Clean up old completed, failed, or cancelled tasks and events
  create-queue    Create a new queue
  drop-queue      Drop an existing queue
  list-queues     List all existing queues
  spawn-task      Spawn a new task
  help            Show this help message

Run 'absurdctl COMMAND --help' for more information on a command.

Environment Variables:
  PGHOST          Database host
  PGPORT          Database port
  PGUSER          Database user
  PGDATABASE      Database name
  PGPASSWORD      Database password (recommended over command line)

Examples:
  absurdctl init
  absurdctl cleanup myqueue 30
  absurdctl create-queue myqueue
  absurdctl drop-queue myqueue --yes
  absurdctl list-queues
  absurdctl spawn-task my-task -P foo=bar -P count:=42
"""
    )


def main():
    if len(sys.argv) < 2 or sys.argv[1] in ("help", "--help", "-h"):
        show_help()
        sys.exit(0)

    command = sys.argv[1]
    args = sys.argv[2:]

    if command == "cleanup":
        cmd_cleanup(args)
    elif command == "create-queue":
        cmd_create_queue(args)
    elif command == "drop-queue":
        cmd_drop_queue(args)
    elif command == "list-queues":
        cmd_list_queues(args)
    elif command == "init":
        cmd_init(args)
    elif command == "spawn-task":
        cmd_spawn_task(args)
    else:
        print(f"Unknown command: {command}", file=sys.stderr)
        print("")
        show_help()
        sys.exit(1)


if __name__ == "__main__":
    main()
